;
; File generated by cc65 v 2.13.3
;
	.fopt		compiler,"cc65 v 2.13.3"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	on
	.importzp	sp, sreg, regsave, regbank, tmp1, ptr1, ptr2
	.macpack	longbranch
	.dbg		file, "sieve.c", 2700, 1513383914
	.dbg		file, "/usr/local/lib/cc65/include/stdlib.h", 5578, 1513373554
	.dbg		file, "/usr/local/lib/cc65/include/stdio.h", 5964, 1513373554
	.dbg		file, "/usr/local/lib/cc65/include/stddef.h", 2972, 1513373554
	.dbg		file, "/usr/local/lib/cc65/include/stdarg.h", 2817, 1513373554
	.dbg		file, "/usr/local/lib/cc65/include/ctype.h", 7770, 1513373554
	.dbg		file, "/usr/local/lib/cc65/include/time.h", 5015, 1513373554
	.dbg		file, "/usr/local/lib/cc65/include/conio.h", 8680, 1513373554
	.dbg		file, "/usr/local/lib/cc65/include/cbm.h", 10222, 1513373554
	.dbg		file, "/usr/local/lib/cc65/include/c64.h", 4561, 1513373554
	.dbg		file, "/usr/local/lib/cc65/include/_vic2.h", 5469, 1513373554
	.dbg		file, "/usr/local/lib/cc65/include/_sid.h", 3356, 1513373554
	.dbg		file, "/usr/local/lib/cc65/include/_6526.h", 3677, 1513373554
	.forceimport	__STARTUP__
	.import		_printf
	.import		_toupper
	.import		_clock
	.import		_kbhit
	.import		_cgetc
	.export		_main

.segment	"RODATA"

L0001:
	.byte	$D3,$49,$45,$56,$45,$20,$42,$45,$4E,$43,$48,$4D,$41,$52,$4B,$20
	.byte	$2D,$20,$43,$41,$4C,$43,$55,$4C,$41,$54,$49,$4E,$47,$20,$50,$52
	.byte	$49,$4D,$45,$53,$0D,$00,$42,$45,$54,$57,$45,$45,$4E,$20,$32,$20
	.byte	$41,$4E,$44,$20,$25,$55,$0D,$00,$D0,$4C,$45,$41,$53,$45,$20,$57
	.byte	$41,$49,$54,$20,$50,$41,$54,$49,$45,$4E,$54,$4C,$59,$20,$2E,$2E
	.byte	$2E,$0D,$00,$D4,$49,$4D,$45,$20,$55,$53,$45,$44,$3A,$20,$25,$55
	.byte	$2E,$25,$30,$33,$55,$20,$53,$45,$43,$4F,$4E,$44,$53,$0D,$00,$D1
	.byte	$20,$54,$4F,$20,$51,$55,$49,$54,$2C,$20,$41,$4E,$59,$20,$4F,$54
	.byte	$48,$45,$52,$20,$4B,$45,$59,$20,$46,$4F,$52,$20,$4C,$49,$53,$54
	.byte	$0D,$00,$25,$34,$44,$0D,$00,$D1,$20,$54,$4F,$20,$51,$55,$49,$54
	.byte	$2C,$20,$41,$4E,$59,$20,$4F,$54,$48,$45,$52,$20,$4B,$45,$59,$20
	.byte	$43,$4F,$4E,$54,$49,$4E,$55,$45,$53,$0D,$00

.segment	"BSS"

_Sieve:
	.res	16384,$00

; ---------------------------------------------------------------
; unsigned char __near__ ReadUpperKey (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ReadUpperKey: near

.segment	"CODE"

;
; return toupper (cgetc ());
;
	.dbg	line, "sieve.c", 48
	jsr     _cgetc
	ldx     #$00
	jmp     _toupper
	.dbg	line

.endproc

; ---------------------------------------------------------------
; int __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"BSS"

L000B:
	.res	4,$00
L000C:
	.res	2,$00
L000D:
	.res	2,$00

.segment	"CODE"

;
; register unsigned char* S;
;
	.dbg	line, "sieve.c", 61
	lda     regbank+4
	ldx     regbank+5
	jsr     pushax
;
; register unsigned      I;
;
	.dbg	line, "sieve.c", 62
	lda     regbank+2
	ldx     regbank+3
	jsr     pushax
;
; register unsigned      J;
;
	.dbg	line, "sieve.c", 63
	lda     regbank+0
	ldx     regbank+1
	jsr     pushax
;
; printf ("Sieve benchmark - calculating primes\n");
;
	.dbg	line, "sieve.c", 66
	lda     #<(L0001)
	ldx     #>(L0001)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; printf ("between 2 and %u\n", COUNT);
;
	.dbg	line, "sieve.c", 67
	lda     #<(L0001+38)
	ldx     #>(L0001+38)
	jsr     pushax
	ldx     #$40
	lda     #$00
	jsr     pushax
	ldy     #$04
	jsr     _printf
;
; printf ("Please wait patiently ...\n");
;
	.dbg	line, "sieve.c", 68
	lda     #<(L0001+56)
	ldx     #>(L0001+56)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; Ticks = clock();
;
	.dbg	line, "sieve.c", 71
	jsr     _clock
	sta     L000B
	stx     L000B+1
	ldy     sreg
	sty     L000B+2
	ldy     sreg+1
	sty     L000B+3
;
; I = 2;
;
	.dbg	line, "sieve.c", 74
	ldx     #$00
	lda     #$02
	sta     regbank+2
	stx     regbank+2+1
;
; while (I < SQRT_COUNT) {
;
	.dbg	line, "sieve.c", 75
L0019:	lda     regbank+2+1
	bne     L001C
	lda     regbank+2
	cmp     #$80
L001C:	bcs     L001A
;
; if (Sieve[I] == 0) {
;
	.dbg	line, "sieve.c", 76
	lda     #<(_Sieve)
	sta     ptr1
	lda     #>(_Sieve)
	clc
	adc     regbank+2+1
	sta     ptr1+1
	ldy     regbank+2
	lda     (ptr1),y
	bne     L0026
;
; J = I*2;
;
	.dbg	line, "sieve.c", 78
	lda     regbank+2
	asl     a
	sta     regbank+0
	lda     regbank+2+1
	rol     a
	sta     regbank+0+1
;
; S = &Sieve[J];
;
	.dbg	line, "sieve.c", 79
	lda     #<(_Sieve)
	clc
	adc     regbank+0
	sta     regbank+4
	lda     #>(_Sieve)
	adc     regbank+0+1
	sta     regbank+4+1
;
; while (J < COUNT) {
;
	.dbg	line, "sieve.c", 80
L0025:	ldx     regbank+0+1
	cpx     #$40
	bcs     L0026
;
; *S = 1;
;
	.dbg	line, "sieve.c", 81
	lda     #$01
	ldy     #$00
	sta     (regbank+4),y
;
; S += I;
;
	.dbg	line, "sieve.c", 82
	lda     regbank+2
	clc
	adc     regbank+4
	sta     regbank+4
	lda     regbank+2+1
	adc     regbank+4+1
	sta     regbank+4+1
;
; J += I;
;
	.dbg	line, "sieve.c", 83
	lda     regbank+2
	clc
	adc     regbank+0
	sta     regbank+0
	lda     regbank+2+1
	adc     regbank+0+1
	sta     regbank+0+1
;
; }
;
	.dbg	line, "sieve.c", 84
	jmp     L0025
;
; ++I;
;
	.dbg	line, "sieve.c", 86
L0026:	inc     regbank+2
	bne     L0019
	inc     regbank+2+1
;
; }
;
	.dbg	line, "sieve.c", 87
	jmp     L0019
;
; Ticks = clock() - Ticks;
;
	.dbg	line, "sieve.c", 90
L001A:	jsr     _clock
	jsr     pusheax
	lda     L000B+3
	sta     sreg+1
	lda     L000B+2
	sta     sreg
	ldx     L000B+1
	lda     L000B
	jsr     tossubeax
	sta     L000B
	stx     L000B+1
	ldy     sreg
	sty     L000B+2
	ldy     sreg+1
	sty     L000B+3
;
; Sec = (unsigned) (Ticks / CLOCKS_PER_SEC);
;
	.dbg	line, "sieve.c", 91
	lda     L000B+3
	sta     sreg+1
	lda     L000B+2
	sta     sreg
	ldx     L000B+1
	lda     L000B
	jsr     pusheax
	ldx     #$00
	lda     #$3C
	jsr     tosudiv0ax
	sta     L000C
	stx     L000C+1
;
; Milli = ((Ticks % CLOCKS_PER_SEC) * 1000) / CLOCKS_PER_SEC;
;
	.dbg	line, "sieve.c", 92
	lda     L000B+3
	sta     sreg+1
	lda     L000B+2
	sta     sreg
	ldx     L000B+1
	lda     L000B
	jsr     pusheax
	ldx     #$00
	lda     #$3C
	jsr     tosumod0ax
	jsr     pusheax
	ldx     #$03
	lda     #$E8
	jsr     tosumul0ax
	jsr     pusheax
	ldx     #$00
	lda     #$3C
	jsr     tosudiv0ax
	sta     L000D
	stx     L000D+1
;
; printf ("Time used: %u.%03u seconds\n", Sec, Milli);
;
	.dbg	line, "sieve.c", 95
	lda     #<(L0001+83)
	ldx     #>(L0001+83)
	jsr     pushax
	lda     L000C
	ldx     L000C+1
	jsr     pushax
	lda     L000D
	ldx     L000D+1
	jsr     pushax
	ldy     #$06
	jsr     _printf
;
; printf ("Q to quit, any other key for list\n");
;
	.dbg	line, "sieve.c", 96
	lda     #<(L0001+111)
	ldx     #>(L0001+111)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; if (ReadUpperKey () != 'Q') {
;
	.dbg	line, "sieve.c", 99
	jsr     _ReadUpperKey
	cmp     #$D1
	jeq     L0044
;
; J = 0;
;
	.dbg	line, "sieve.c", 101
	ldx     #$00
	txa
	sta     regbank+0
	sta     regbank+0+1
;
; for (I = 2; I < COUNT; ++I) {
;
	.dbg	line, "sieve.c", 102
	lda     #$02
	sta     regbank+2
	stx     regbank+2+1
L0043:	ldx     regbank+2+1
	cpx     #$40
	bcs     L0044
;
; if (Sieve[I] == 0) {
;
	.dbg	line, "sieve.c", 103
	lda     #<(_Sieve)
	sta     ptr1
	lda     #>(_Sieve)
	clc
	adc     regbank+2+1
	sta     ptr1+1
	ldy     regbank+2
	lda     (ptr1),y
	bne     L0052
;
; printf ("%4d\n", I);
;
	.dbg	line, "sieve.c", 104
	lda     #<(L0001+146)
	ldx     #>(L0001+146)
	jsr     pushax
	lda     regbank+2
	ldx     regbank+2+1
	jsr     pushax
	ldy     #$04
	jsr     _printf
;
; if (++J == 23) {
;
	.dbg	line, "sieve.c", 105
	inc     regbank+0
	bne     L0054
	inc     regbank+0+1
L0054:	lda     regbank+0+1
	bne     L0052
	lda     regbank+0
	cmp     #$17
	bne     L0052
;
; printf ("Q to quit, any other key continues\n");
;
	.dbg	line, "sieve.c", 106
	lda     #<(L0001+151)
	ldx     #>(L0001+151)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; if (ReadUpperKey () == 'Q') {
;
	.dbg	line, "sieve.c", 107
	jsr     _ReadUpperKey
	cmp     #$D1
;
; break;
;
	.dbg	line, "sieve.c", 108
	beq     L0044
;
; J = 0;
;
	.dbg	line, "sieve.c", 110
	lda     #$00
	sta     regbank+0
	sta     regbank+0+1
;
; if (kbhit() && ReadUpperKey == 'Q') {
;
	.dbg	line, "sieve.c", 113
L0052:	jsr     _kbhit
	tax
	beq     L0045
	lda     #<(_ReadUpperKey)
	ldx     #>(_ReadUpperKey)
	jsr     pusheax
	ldx     #$00
	stx     sreg
	stx     sreg+1
	lda     #$D1
	jsr     toseqeax
	bne     L0044
;
; for (I = 2; I < COUNT; ++I) {
;
	.dbg	line, "sieve.c", 102
L0045:	inc     regbank+2
	bne     L0043
	inc     regbank+2+1
	jmp     L0043
;
; return EXIT_SUCCESS;
;
	.dbg	line, "sieve.c", 119
L0044:	ldx     #$00
	txa
;
; }
;
	.dbg	line, "sieve.c", 120
	pha
	tay
L0061:	lda     (sp),y
	sta     regbank+0,y
	iny
	cpy     #$06
	bne     L0061
	pla
	jmp     incsp6
	.dbg	line

.endproc

